Date: 2023-05-16
Title: SQL 복수행 함수(그룹 함수)를 배웁시다.


1. GROUP 함수의 종류

SQL 복수행 함수는 앞에서 살펴본 단일행 함수와 달리 한꺼번에 여러 건의 데이터가 함수로 입력된다.

  1.1 COUNT() 함수
      입력되는 데이터의 총 건수를 반환한다.
      
      select COUNT(*), COUNT(COMM) from emp;
      
  1.2 SUM() 함수
      입력된 데이터들의 합계 값을 구하는 함수이다.
      
      
      set null --null--;
      
      select ename, comm from emp;
      
      
      
      select COUNT(comm), SUM(comm) from emp;
      
      
  1.3 AVG() 함수
      입력된 값들의 평균 값을 구해주는 함수이다.
      
      
      SELECT COUNT(COMM), SUM(COMM), AVG(COMM) from emp;
  
  
  
      SELECT COUNT(*), SUM(COMM), AVG(NVL(comm,0)) from emp;
      
      
      
  1.4 MAX() 함수/ MIN() 함수
      MAX 함수는 주어진 데이터 중에서 가장 큰 값을 돌려주고, MIN 함수는 반대로 가장 작은 값을 돌려준다.
      
      SELECT MAX(sal), MIN(sal) from emp;
      
     
      SELECT MAX(hiredate) "MAX", MIN(hiredate) "MIN" from emp;
      
      
  1.5 STDDEV() 함수/ VARIANCE() 함수
      STDDEV() 함수는 표준 편차를 구하는 함수이며 VARIANCE() 함수는 분산을 구하는 함수이다.
      
      
      SELECT STDDEV(sal), VARIANCE(sal) from emp;
      
      
      
      
  2. GROUP BY 절을 사용해 특정 조건으로 세부적인 그룹화하기
     전체 값을 조회하는 것이 아니라 특정 조건을 주고 해당 조건에 맞는 결과들을 모아서 조금 더 구체적인 결과를 만듬
     
     예시1:
     SELECT deptno, AVG(NVL(sal,0)) "AVG" from emp group by deptno;
  
  
     예시2:
     select deptno, job, avg(NVL(sal,0)) "AVG_SAL" from emp GROUP by deptno, job;
  
      
     예시3:
     SELECT deptno, job, avg(nvl(sal,0)) "AVG_SAL" from emp GROUP BY deptno, job ORDER by 1,2;
        -> GROUP BY 결과 정렬이 안되어서 수동으로 정렬함
        
        
     예시4:
     select deptno, job, avg(nvl(sal,0)) "AVG_SAL" from emp GROUP BY deptno;
     -> GROUP BY 절에 사용된 컬럼이라도 select 절에는 사용되지 않아도 된다.
     
     
     예시5:
     select deptno no, job, avg(NVL(sal,0)) "AVG_SAL" from emp GROUP by no;
     ->
     
     
     
     
     3. Having 절을 사용해 그룹핑한 조건으로 검색
     
     예시6:
     select deptno, AVG(NVL(SAL,0)) from emp where AVG(NVL(sal,0)) > 2000;
     WHERE AVG(NVL(sal,0)) > 2000
     
     
     where 그룹 함수를 비교 조건으로 쓸 수가 없기 떄문이다.
     
     
     예시7:
     select deptno, avg(NVL(sal,0)) from emp where deptno > 10 group by deptno Having AVG(NVL(sal,0)) > 2000;
     
     
     
     4. 반드시 알아야 하는 다양한 분석 함수들
        
        
     4.1 각 기준별 소계를 요약해서 보여 주는 ROLLUP()함수
         
         예시1:
         부서와 직업별 평균 급여 및 사원 수와 부서별 평균 급여와 사원 수, 전체 사원의 평균 급여와 사원 수를 구하세요.
         
         - 부서와 직업별 평균 급여 및 사원 수
         - 부서별 평균 급여와 사원 수
         - 전체 사원의 평균 급여와 사원 수
         
         SELECT deptno, NULL job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp from emp
         GROUP BY deptno
         UNION ALL
         SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) ent_emp
         FROM emp
         GROUP BY deptno, job
         UNION ALL
         SELECT null deptno, null job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
         FROM emp
         ORDER BY deptno, job;
         
         
         -> SQL 문장이 기니 ROLLUP 그룹 함수를 사용해서 SQL문을 만들어라
         
         GROUP BY ROLLUP (DEPTNO, JOB); M+1;
                           -------> 1. DEPTNO 그룹 집계
                                    2. DEPTNO, JOB 그룹 집계
                                    3. 전체 그룹 집계
         
         SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp From emp GROUP BY ROLLUP (Deptno, job);
     
     
        예시2:
        SELECT deptno, position, COUNT(*), SUM(PAY) FROM professor GROUP BY position, ROLLUP(deptno);
        
        
        예시3:
        SELECT deptno, position, COUNT(*), SUM(PAY) FROM professor GROUP BY deptno, ROLLUP(position);
        
        
        
        예시4:
        -> setting 시작
        CREATE TABLE professor2
        AS SELECT deptno, position, pay
        FROM professor;
        
        SELECT * FROM professor2;
        
        
        
        -> 테이블에 값 입력
        
        INSERT INTO professor2 VALUES(101, 'instructor' , 100);
        
        INSERT INTO professor2 VALUES(101, 'a full professor', 100);
        
        INSERT INTO professor2 VALUES(101, 'assistant professor', 100);
        
        commit;
        
        
        SELECT * FROM professor2 ORDER BY deptno, position;
        
        
        
        
        예시5:
        SELECT deptno, position, SUM(pay)
        FROM professor2
        GROUP BY deptno, ROLLUP(position);
        
        
        일반 GROUP BY 절의 SQL 실행 계획
        
        explain plan for
        SELECT deptno, NULL job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
        FROM emp
        GROUP BY deptno
        UNION ALL
        SELECT deptno, job, ROUND(AVG(SAL),1) avg_sal, COUNT(*) cnt_emp
        FROM emp
        GROUP BY deptno, job
        UNION ALL
        SELECT NULL deptno, NULL job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
        FROM emp
        ORDER BY deptno, job
        ;
        
        
        col PLAN_TABLE_OUTPUT format a80
        
        select * from table(dbms_xplan.display);
        
        
        
        [ROLLUP 그룹 함수 SQL 실행 계획]
        
        SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
        FROM emp
        GROUP BY ROLLUP (deptno, job);
        
        
        
        예시6:
        col PLAN_TABLE_OUTPUT format a80
        select * from table(dbms_xplan.display);



        4.2 CUBE() 함수 - 소계와 전체 합계까지 출력하는 함수
        CUBE 함수는 ROLLUP() 함수와 같이 각 소계도 출력하고 추가로 전체 총계까지 출력한다.
        
        
        사용 예1
        부서별 평균 급여와 사원 수, 직급별 평균 급여와 사원 수, 부서와 직급별 평균 급여와 사원 수, 전체 평균 월 급여와 사원 수를 구하세요.
        
        
        위 문제를 해결하려면, 총 4개의 그룹이 필요하다.
        
        - 부서별 평균 급여와 사원 수
        - 직급별 평균 급여와 사원 수
        - 부서와 직급별 평균 급여와 사원 수
        - 전체 평균 월 급여와 사원 수
        
        
        SELECT deptno, NULL JOB, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY deptno
        UNION ALL
        SELECT NULL deptno, job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY job
        UNION ALL
        SELECT deptno, job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY deptno, job
        UNION ALL
        SELECT NULL deptno, NULL job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        Order by deptno, job;
        
        
        
        일반 GROUP BY 절의 SQL 실행 계획
        
        ->
        explain plan for
        select deptno, NULL JOB, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY deptno
        UNION ALL
        SELECT NULL deptno, job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY job
        UNION ALL
        SELECT deptno, job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY deptno, job
        UNION ALL
        SELECT NULL deptno, NULL job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        ORDER BY deptno, job;
        
        
        col Plan_Table_Output format a80
        select * from table(dbms_xplan.display);
        
        -> 위의 쿼리를 작성해서 실행하면, CPU의 몇퍼센트를 사용하는지 알 수 있다.
        
        
        이번에는 동일한 결과를 얻기 위해 CUBE() 함수를 사용하여 SQL문을 작성한다.
        참고로 CUBE() 함수에 지정된 컬럼들의 수를 N일 때 2*N승 소계(소그룹)이 생성된다.
        
        문법: 
        
        GROUP BY ROLLUP (DEPTNO, JOB) ; -> 2*N 그룹이 생김 (ROLLUP에 비해 연산을 많이 함)
                          ㄴ 
                              1. deptno 그룹 집계
                              2. job 그룹 집계
                              3. deptno, job 그룹 집계
                              4. 전체 그룹 집계
       
       
       SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
       FROM emp
       GROUP BY CUBE (deptno, job)
       ORDER BY deptno, job;
       
       
       cube()함수 SQL 실행 계획
       ->
       explain plan for
       SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
       FROM emp
       GROUP BY CUBE (deptno, job)
       ORDER BY deptno, job;
       
       col PLAN_TABLE_OUTPUT format a80
       select * from table(dbms_xplan.display);
       
       
       CUBE 함수를 사용하면 SQL이 훨씬 간결해지고 EMP 테이블도 1번만 읽습니다.
       
       
       
       
       4.3 GROUPING SETS() 함수
       
       그루핑 조건이 여러 개일 경우 아주 유용하게 사용된다.
       
       예시1: student 테이블에서 학년별로 학생들의 인원수 합계와 학과별로 인원수의 합계를 구해야 하는 경우에 기존에는 학년별로 인원수 합계를 구하고 별도로 학과별로 인원수 합계를 구한 후 UNION 연산을 했어야 했다.
       
       SELECT grade, COUNT(*)
       FROM  student
       GROUP BY grade
       UNION
       SELECT deptno1, COUNT(*)
       FROM student
       GROUP BY deptno1;
       
        -> 기존 방법으로 조회
        
        
        SELECT grade, deptno1, COUNT(*)
        FROM student
        GROUP BY GROUPING SETS(grade, deptno1);

        -> GROUPING SETS를 사용하여 조회를 한 화면
        
        
        
        예시2:
        SELECT grade, deptno1, COUNT(*), SUM(height), SUM(weight)
        FROM student
        GROUP BY GROUPING SETS(grade, deptno1);
        
        
        4.4 LISTAGG()함수
        
        예시 1:
        SET LINE 200
        COL listagg FOR a50
        SELECT deptno,
               LISTAGG(ename, '->') WITHIN GROUP (ORDER BY hiredate) "LISTAGG"
        FROM emp
        GROUP BY deptno;
        
        -> 주의 사항, Return 되는 값이 4000 BYTE가 넘을 경우 오류가 발생한다.
        
        ***참고
        만약 저장된 4,000 바이트가 넘는 출력 결과를 나올 수 있다면 그 형태는 VARCHAR2 형태나 CLOB 형태가 있다
        각각의 형태에 따라 쿼리가 달라지는데 문법이 약간 다르다
        
        예시 2: Return type이 varchar2 형태일 때.
        
        SELECT deptno,
                  SUBSTR(
                    XMLAGG(XMLELEMENT(X, ',', ename) ORDER BY ename)
        .EXTRACT('//text()').getStringVal()
                 ,2) AS DEPT_ENAME_LIST
        FROM emp A
        GROUP BY deptno;
        
        
        예시 3: RETURN type: CLOB
        
        SELECT deptno,
                  SUBSTR(
                    XMLAGG(XMLELEMENT(X, ',' , ename) ORDER BY ename)
                          .EXTRACT('//text()').getStringVal()
                ,2) AS DEPT_ENAME_LIST
        FROM emp A
        GROUP BY deptno;
        
        
        
        
        
        4.5 PIVOT() 함수
        PIVOT 함수는 row 단위를 column 단위로 변경해 주고 UNPIVOT 함수는 반대로 column 단위를 row 단위로 변경해 주는 기능.
        
        (1) Pivot 기능을 사용하지 않고 decode 함수를 활용하여 달력 만든다.
        
        예시1:
        COL sun FOR a4
        COL mon FOR a4
        COL tue FOR a4
        COL wed FOR a4
        COL thu FOR a4
        COL fri FOR a4
        COL sat FOR a4
        
        SELECT MAX(DECODE(day, 'SUN', dayno)) SUN ,
               MAX(DECODE(day, 'MON', dayno)) MON ,
               MAX(DECODE(day, 'TUE', dayno)) TUE ,
               MAX(DECODE(day, 'WED', dayno)) WED ,
               MAX(DECODE(day, 'THU', dayno)) THU ,
               MAX(DECODE(day, 'FRI', dayno)) FRI ,
               MAX(DECODE(day, 'SAT', dayno)) SAT
        FROM cal
        GROUP BY weekno
        ORDER BY weekno;
               
               
               
        첫 번쨰 단계로 먼저 DECODE() 부분
        
        예시2:
        SELECT DECODE(day, 'SUN', dayno) SUN,
               DECODE(day, 'MON', dayno) MON,
               DECODE(day, 'TUE', dayno) TUE,
               DECODE(day, 'WED', dayno) WED,
               DECODE(day, 'THU', dayno) THU,
               DECODE(day, 'FRI', dayno) FRI,
               DECODE(day, 'SAT', dayno) SAT
        FROM cal;
               
        
        
        예시3:
        
        SELECT MAX(DECODE(day, 'SUN', dayno)) SUN,
               MAX(DECODE(day, 'MON', dayno)) MON,
               MAX(DECODE(day, 'TUE', dayno)) TUE,
               MAX(DECODE(day, 'WED', dayno)) WED,
               MAX(DECODE(day, 'THU', dayno)) THU,
               MAX(DECODE(day, 'FRI', dayno)) FRI,
               MAX(DECODE(day, 'SAT', dayno)) SAT
        FROM cal;
        
        
        
        예시4:
        
        SEELCT ASCII('2') FROM dual;
        
        SELECT ASCII('29') FROM dual;
        
        SELECT ASCII('8') FROM dual;
        
        
        
        예시5:
        
        SELECT MAX(DECODE(day, 'SUN', dayno)) SUN,
               MAX(DECODE(day, 'MON', dayno)) MON,
               MAX(DECODE(day, 'TUE', dayno)) TUE,
               MAX(DECODE(day, 'WED', dayno)) WED,
               MAX(DECODE(day, 'THU', dayno)) THU,
               MAX(DECODE(day, 'FRI', dayno)) FRI,
               MAX(DECODE(day, 'SAT', dayno)) SAT
        FROM cal
        GROUP BY weekno;
        
        
        
        예시6:
        
        SELECT MAX(DECODE(day, 'SUN', dayno)) SUN,
               MAX(DECODE(day, 'MON', dayno)) MON,
               MAX(DECODE(day, 'TUE', dayno)) TUE,
               MAX(DECODE(day, 'WED', dayno)) WED,
               MAX(DECODE(day, 'THU', dayno)) THU,
               MAX(DECODE(day, 'FRI', dayno)) FRI,
               MAX(DECODE(day, 'SAT', dayno)) SAT
        FROM cal
        GROUP BY weekno
        ORDER BY weekno;
        
        
        (2) PIVOT 기능을 사용하여 달력 만들기
        
        예시1
        COL week FOR a4
        SELECT * FROM (SELECT weekno "WEEK", day, dayno FROM cal)
        PIVOT
        ( MAX(dayno) FOR day IN('SUN' AS "SUN" ,
                                'MON' AS "MON" ,
                                'TUE' AS "TUE" ,
                                'WED' AS "WED" ,
                                'THU' AS "THU" ,
                                'FRI' AS "FRI" ,
                                'SAT' AS "SAT" )
         )
         ORDER BY "WEEEK" ;
         
         
         (3)  EMP 테이블에서 부서별로 각 직급별 인원이 몇 명인지 계산하기
         * DECODE() 함수를 사용하는 방법
         
         예시1:
         SELECT deptno,
                COUNT(DECODE(job, 'CLERK', '0'))     "CLERK",
                COUNT(DECODE(job, 'MANAGER', '0'))   "MANAGER",
                COUNT(DECODE(job, 'PRESIDENT', '0')) "PRESIDENT",
                COUNT(DECODE(job, 'ANALYST', '0'))   "ANALYST",
                COUNt(DECODE(job, 'SALESMAN', '0'))  "SALESMAN"
         FROM emp
         GROUP BY deptno
         ORDER BY deptno;
         
         -> JOB이 CLERK라면 0을 출력해라.
         
         
         예시2:
         
         SELECT deptno,
                COUNT(DECODE(job, 'CLERK', '0'))     "CLERK",
                COUNT(DECODE(job, 'MANAGER', '0'))   "MANAGER",
                COUNT(DECODE(job, 'PRESIDENT', '0')) "PRESIDENT",
                COUNT(DECODE(job, 'ANALYST', '0'))   "ANALYST",
                COUNt(DECODE(job, 'SALESMAN', '0'))  "SALESMAN"
         FROM emp;
         
         
         
         예시3:
         
         COL CLERK FOR 9999999
         COL MANAGER FOR 9999999
         COL PRESIDENT FOR 9999999
         COL ANALYST FOR 9999999
         COL SALESMAN FOR 9999999
         
         SELECT deptno,
               COUNT(DECODE(job, 'CLERK', '9'))     "CLERK",
               COUNT(DECODE(job, 'MANAGER', '9'))   "MANAGER",
               COUNT(DECODE(job, 'PRESIDENT', '9'))  "PRESIDENT",
               COUNT(DECODE(job, 'ANALYST', '9'))   "ANALYST",
               COUNT(DECODE(job, 'SALESMAN', '9'))  "SALESMAN"
         FROM emp
         GROUP BY deptno;
         
         
         
         예시4:
         SELECT * FROM (SELECT deptno, job, empno FROM emp)
         PIVOT
         (
              COUNT(empno) FOR  job IN ('CLERK' AS "CLERK",
                                        'MANAGER' AS "MANAGER",
                                        'PRESIDENT' AS "PRESIDENT",
                                        'ANALYST' AS "ANALYST",
                                        'SALEMAN' AS "SALESMAN")
         )
         ORDER BY deptno;
         
         
         
         예시5:
         COL C_COUNT FOR 9999999
         COL C_SUM FOR 9999999
         COL M_COUNT FOR 9999999
         COL M_SUM FOR 9999999
         COL P_COUNT FOR 9999999
         COL P_SUM FOR 9999999
         COL A_COUNT FOR 9999999
         COL A_SUM FOR 9999999
         COL S_COUNT FOR 9999999
         COL S_SUM FOR 9999999
         
         SELECT * FROM (SELECT deptno, job, empno, sal
                        FROM emp )
         PIVOT
         (
              COUNT(empno) AS COUNT,
              SUM(NVL(sal,0)) AS SUM FOR job IN('CLERK' AS      "C",
                                                'MANAGER' AS    "M",
                                                'PRESIDENT' AS  "p",
                                                'ANALYST' AS    "A",
                                                'SALESMAN' AS   "S" )
          )
          ORDER BY deptno;
                                                



          4.6 UNPIVOT() 함수
          UNPIVOT 테이블은 PIVOT과 반대의 개념으로 합쳐 있는 것을 풀어서 보여주는 역할을 한다.
          
          테스트를 위한 아래의 테이블 생성
          
          CREATE TABLE Upivot
          AS SELECT * FROM (SELECT deptno, job, empno from emp)
            PIVOT
            (
              COUNT(empno)
                FOR job IN  ('CLERK' AS "CLERK", 
                             'MANAGER' AS "MANAGER",
                             'PRESIDENT' AS "PRESIDENT",
                             'ANALYST' AS "ANALYST",
                             'SALESMAN' AS "SALESMAN")
            );
            
            select * from upivot;



          예시2:
          SELECT * FROm upivot
          unpivot (
          empno FOR job in (CLerk,Manager, PRESIDENT, ANALYST, SALESMAN) );
          
          -> Unpivot으로 위의 결과를 풀기 가능
          
          
          
          4.7 LAG() 함수
          
          문법:
          
          LAG(출력할 컬럼명, OFFSET, 기본 출력 값)
          OVER(Query_partition구문, ORDER BY 정렬할 컬럼)
          
          
          예시1:
          SELECT ename, hiredate, sal,
                 LAG(sal, 1, 0) OVER (ORDER BY hiredate) "LAG"
          FROM emp;
          
          
          예시2:
          SELECT ename, hiredate, sal,
                 LAG(sal, 3,2) OVER (ORDER BY hiredate) "LAG"
          FROM emp;
          
          
          
          
          4.8 LEAD() 함수
          
          LEAD() 함수는 LAG()함수와 반대로 이후의 값을 가져오는 함수이다.
          
          
          예시1:
          SELECT ename, hiredate, sal,
                 LEAD(sal, 2, 1) OVER (ORDER by hiredate) "LEAD"
          FROM emp;
          
          
          
          
          4.9 RANK() 함수 - 순위 출력 함수
          
          RANK 함수는 주어진 컬럼 값의 그룹에서 값의 순위를 계싼한 후 순위를 출력해 준다.
          
          
          * 특정 데이터의 순위 확인하기
          RANK(조건 값) WITHIN GROUP (ORDER BY 조건 값 컬럼명 [ASC | DESC] )
          
          
          예시1:
          SELECT RANK('SMITH') WITHIN GROUP (ORDER BY ename) "RANK"
          FROM emp;
          
          select ename FROM emp ORDER BY ename;
          
          
          
          예시2:
          -> RANK 뒤에 나오는 데이터와 ORDER BY 뒤에 나오는 데이터는 같은 컬럼이어야 한다.
          
          SELECT RANK('SMITH') WITHIN GROUP (ORDER BY hiredate) "RANK"
          FROM emp;
          
          SELECT RANK('SMITH') WITHIN GROUP (ORDER BY hiredate) "RANK"
          -> 에러가 뜬다. 입사일로 정렬시켜 놓고 이름의 순위를 찾아서 에러 발생
          
          
          * RANK () OVER (ORDER BY 조건컬럼명 [ASC | DESC ] )
          
          예시1:
          emp 테이블에서 사원들의 empno, ename, sal, 급여 순위를 출력하세요.
          
          SELECT empno, ename, sal,
                 RANK() OVER (ORDER BY sal ) AS RANK_ASC,
                 RANK() OVER (ORDER BY sal DESC) AS RANK_DESC
          FROM emp;
          
          
          
          예시2:
          emp 테이블에서 10번 부서에 속한 직원들의 사번과 이름, 급여, 해당 부서 내의 급여 순위를 출력하세요.
          
          SELECT empno, ename, sal,
                RANK() OVER (ORDER BY sal DESC) "RANK"
          FROM emp
          WHERE deptno =10;
         
         
         
         예시3:
         emp 테이블을 조회하여 사번, 이름, 급여, 부서번호, 부서별 급여 순위를 출력하시요(부서별 급여 순위 부분을 잘 보세요)
         
         SELECT empno, ename, sal, deptno,
                RANK() OVER (PARTITION BY deptno
                             ORDER BY sal DESC) "RANK"
         FROM emp;
          
          
          
          
          
