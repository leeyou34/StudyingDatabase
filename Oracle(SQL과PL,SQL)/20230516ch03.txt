Date: 2023-05-16
Title: SQL 복수행 함수(그룹 함수)를 배웁시다.


1. GROUP 함수의 종류

SQL 복수행 함수는 앞에서 살펴본 단일행 함수와 달리 한꺼번에 여러 건의 데이터가 함수로 입력된다.

  1.1 COUNT() 함수
      입력되는 데이터의 총 건수를 반환한다.
      
      select COUNT(*), COUNT(COMM) from emp;
      
  1.2 SUM() 함수
      입력된 데이터들의 합계 값을 구하는 함수이다.
      
      
      set null --null--;
      
      select ename, comm from emp;
      
      
      
      select COUNT(comm), SUM(comm) from emp;
      
      
  1.3 AVG() 함수
      입력된 값들의 평균 값을 구해주는 함수이다.
      
      
      SELECT COUNT(COMM), SUM(COMM), AVG(COMM) from emp;
  
  
  
      SELECT COUNT(*), SUM(COMM), AVG(NVL(comm,0)) from emp;
      
      
      
  1.4 MAX() 함수/ MIN() 함수
      MAX 함수는 주어진 데이터 중에서 가장 큰 값을 돌려주고, MIN 함수는 반대로 가장 작은 값을 돌려준다.
      
      SELECT MAX(sal), MIN(sal) from emp;
      
     
      SELECT MAX(hiredate) "MAX", MIN(hiredate) "MIN" from emp;
      
      
  1.5 STDDEV() 함수/ VARIANCE() 함수
      STDDEV() 함수는 표준 편차를 구하는 함수이며 VARIANCE() 함수는 분산을 구하는 함수이다.
      
      
      SELECT STDDEV(sal), VARIANCE(sal) from emp;
      
      
      
      
  2. GROUP BY 절을 사용해 특정 조건으로 세부적인 그룹화하기
     전체 값을 조회하는 것이 아니라 특정 조건을 주고 해당 조건에 맞는 결과들을 모아서 조금 더 구체적인 결과를 만듬
     
     예시1:
     SELECT deptno, AVG(NVL(sal,0)) "AVG" from emp group by deptno;
  
  
     예시2:
     select deptno, job, avg(NVL(sal,0)) "AVG_SAL" from emp GROUP by deptno, job;
  
      
     예시3:
     SELECT deptno, job, avg(nvl(sal,0)) "AVG_SAL" from emp GROUP BY deptno, job ORDER by 1,2;
        -> GROUP BY 결과 정렬이 안되어서 수동으로 정렬함
        
        
     예시4:
     select deptno, job, avg(nvl(sal,0)) "AVG_SAL" from emp GROUP BY deptno;
     -> GROUP BY 절에 사용된 컬럼이라도 select 절에는 사용되지 않아도 된다.
     
     
     예시5:
     select deptno no, job, avg(NVL(sal,0)) "AVG_SAL" from emp GROUP by no;
     ->
     
     
     
     
     3. Having 절을 사용해 그룹핑한 조건으로 검색
     
     예시6:
     select deptno, AVG(NVL(SAL,0)) from emp where AVG(NVL(sal,0)) > 2000;
     WHERE AVG(NVL(sal,0)) > 2000
     
     
     where 그룹 함수를 비교 조건으로 쓸 수가 없기 떄문이다.
     
     
     예시7:
     select deptno, avg(NVL(sal,0)) from emp where deptno > 10 group by deptno Having AVG(NVL(sal,0)) > 2000;
     
     
     
     4. 반드시 알아야 하는 다양한 분석 함수들
        
        
     4.1 각 기준별 소계를 요약해서 보여 주는 ROLLUP()함수
         
         예시1:
         부서와 직업별 평균 급여 및 사원 수와 부서별 평균 급여와 사원 수, 전체 사원의 평균 급여와 사원 수를 구하세요.
         
         - 부서와 직업별 평균 급여 및 사원 수
         - 부서별 평균 급여와 사원 수
         - 전체 사원의 평균 급여와 사원 수
         
         SELECT deptno, NULL job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp from emp
         GROUP BY deptno
         UNION ALL
         SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) ent_emp
         FROM emp
         GROUP BY deptno, job
         UNION ALL
         SELECT null deptno, null job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
         FROM emp
         ORDER BY deptno, job;
         
         
         -> SQL 문장이 기니 ROLLUP 그룹 함수를 사용해서 SQL문을 만들어라
         
         GROUP BY ROLLUP (DEPTNO, JOB); M+1;
                           -------> 1. DEPTNO 그룹 집계
                                    2. DEPTNO, JOB 그룹 집계
                                    3. 전체 그룹 집계
         
         SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp From emp GROUP BY ROLLUP (Deptno, job);
     
     
        예시2:
        SELECT deptno, position, COUNT(*), SUM(PAY) FROM professor GROUP BY position, ROLLUP(deptno);
        
        
        예시3:
        SELECT deptno, position, COUNT(*), SUM(PAY) FROM professor GROUP BY deptno, ROLLUP(position);
        
        
        
        예시4:
        -> setting 시작
        CREATE TABLE professor2
        AS SELECT deptno, position, pay
        FROM professor;
        
        SELECT * FROM professor2;
        
        
        
        -> 테이블에 값 입력
        
        INSERT INTO professor2 VALUES(101, 'instructor' , 100);
        
        INSERT INTO professor2 VALUES(101, 'a full professor', 100);
        
        INSERT INTO professor2 VALUES(101, 'assistant professor', 100);
        
        commit;
        
        
        SELECT * FROM professor2 ORDER BY deptno, position;
        
        
        
        
        예시5:
        SELECT deptno, position, SUM(pay)
        FROM professor2
        GROUP BY deptno, ROLLUP(position);
        
        
        일반 GROUP BY 절의 SQL 실행 계획
        
        explain plan for
        SELECT deptno, NULL job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
        FROM emp
        GROUP BY deptno
        UNION ALL
        SELECT deptno, job, ROUND(AVG(SAL),1) avg_sal, COUNT(*) cnt_emp
        FROM emp
        GROUP BY deptno, job
        UNION ALL
        SELECT NULL deptno, NULL job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
        FROM emp
        ORDER BY deptno, job
        ;
        
        
        col PLAN_TABLE_OUTPUT format a80
        
        select * from table(dbms_xplan.display);
        
        
        
        [ROLLUP 그룹 함수 SQL 실행 계획]
        
        SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
        FROM emp
        GROUP BY ROLLUP (deptno, job);
        
        
        
        예시6:
        col PLAN_TABLE_OUTPUT format a80
        select * from table(dbms_xplan.display);



        4.2 CUBE() 함수 - 소계와 전체 합계까지 출력하는 함수
        CUBE 함수는 ROLLUP() 함수와 같이 각 소계도 출력하고 추가로 전체 총계까지 출력한다.
        
        
        사용 예1
        부서별 평균 급여와 사원 수, 직급별 평균 급여와 사원 수, 부서와 직급별 평균 급여와 사원 수, 전체 평균 월 급여와 사원 수를 구하세요.
        
        
        위 문제를 해결하려면, 총 4개의 그룹이 필요하다.
        
        - 부서별 평균 급여와 사원 수
        - 직급별 평균 급여와 사원 수
        - 부서와 직급별 평균 급여와 사원 수
        - 전체 평균 월 급여와 사원 수
        
        
        SELECT deptno, NULL JOB, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY deptno
        UNION ALL
        SELECT NULL deptno, job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY job
        UNION ALL
        SELECT deptno, job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY deptno, job
        UNION ALL
        SELECT NULL deptno, NULL job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        Order by deptno, job;
        
        
        
        일반 GROUP BY 절의 SQL 실행 계획
        
        ->
        explain plan for
        select deptno, NULL JOB, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY deptno
        UNION ALL
        SELECT NULL deptno, job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY job
        UNION ALL
        SELECT deptno, job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        GROUP BY deptno, job
        UNION ALL
        SELECT NULL deptno, NULL job, ROUND(AVG(sal),1) AVG_SAL, COUNT(*) CNT_EMP
        FROM emp
        ORDER BY deptno, job;
        
        
        col Plan_Table_Output format a80
        select * from table(dbms_xplan.display);
        
        -> 위의 쿼리를 작성해서 실행하면, CPU의 몇퍼센트를 사용하는지 알 수 있다.
        
        
        이번에는 동일한 결과를 얻기 위해 CUBE() 함수를 사용하여 SQL문을 작성한다.
        참고로 CUBE() 함수에 지정된 컬럼들의 수를 N일 때 2*N승 소계(소그룹)이 생성된다.
        
        문법: 
        
        GROUP BY ROLLUP (DEPTNO, JOB) ; -> 2*N 그룹이 생김 (ROLLUP에 비해 연산을 많이 함)
                          ㄴ 
                              1. deptno 그룹 집계
                              2. job 그룹 집계
                              3. deptno, job 그룹 집계
                              4. 전체 그룹 집계
       
       
       SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
       FROM emp
       GROUP BY CUBE (deptno, job)
       ORDER BY deptno, job;
       
       
       cube()함수 SQL 실행 계획
       ->
       explain plan for
       SELECT deptno, job, ROUND(AVG(sal),1) avg_sal, COUNT(*) cnt_emp
       FROM emp
       GROUP BY CUBE (deptno, job)
       ORDER BY deptno, job;
       
       col PLAN_TABLE_OUTPUT format a80
       select * from table(dbms_xplan.display);
       
       
       CUBE 함수를 사용하면 SQL이 훨씬 간결해지고 EMP 테이블도 1번만 읽습니다.
       
       
       
       
       4.3 GROUPING SETS() 함수
       
       
        
